{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///Users/benkennon/dawg-ai/app/api/team-chat/route.ts"],"sourcesContent":["/**\n * Team Chat API\n * Real-time chat system for coordinating between user and all agents\n */\n\nimport { NextResponse } from 'next/server';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport const dynamic = 'force-dynamic';\n\ninterface ChatMessage {\n  id: string;\n  timestamp: string;\n  from: string; // 'user' or agent name\n  to?: string; // Optional: specific agent, or 'all'\n  message: string;\n  type: 'user' | 'agent' | 'system';\n  read: boolean;\n}\n\nconst CHAT_FILE = path.join(process.cwd(), '_bus', 'team-chat.jsonl');\n\n// Ensure chat file exists\nasync function ensureChatFile() {\n  try {\n    await fs.access(CHAT_FILE);\n  } catch {\n    await fs.mkdir(path.dirname(CHAT_FILE), { recursive: true });\n    await fs.writeFile(CHAT_FILE, '');\n  }\n}\n\n// GET - Fetch recent messages\nexport async function GET(request: Request) {\n  try {\n    await ensureChatFile();\n\n    const { searchParams } = new URL(request.url);\n    const since = searchParams.get('since'); // Timestamp to fetch messages after\n    const limit = parseInt(searchParams.get('limit') || '50');\n    const agent = searchParams.get('agent'); // Filter for specific agent\n\n    const content = await fs.readFile(CHAT_FILE, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n\n    let messages: ChatMessage[] = lines\n      .map((line) => {\n        try {\n          return JSON.parse(line);\n        } catch {\n          return null;\n        }\n      })\n      .filter(Boolean);\n\n    // Filter by timestamp if provided\n    if (since) {\n      const sinceTime = new Date(since).getTime();\n      messages = messages.filter((m) => new Date(m.timestamp).getTime() > sinceTime);\n    }\n\n    // Filter for specific agent (messages to them or from them)\n    if (agent) {\n      messages = messages.filter(\n        (m) => m.to === agent || m.to === 'all' || m.from === agent\n      );\n    }\n\n    // Get most recent messages\n    messages = messages.slice(-limit);\n\n    return NextResponse.json({\n      messages,\n      count: messages.length,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('[TeamChat] Failed to fetch messages:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch messages' },\n      { status: 500 }\n    );\n  }\n}\n\n// POST - Send a new message\nexport async function POST(request: Request) {\n  try {\n    await ensureChatFile();\n\n    const body = await request.json();\n    const { from, to, message, type } = body;\n\n    if (!from || !message) {\n      return NextResponse.json(\n        { error: 'from and message are required' },\n        { status: 400 }\n      );\n    }\n\n    const chatMessage: ChatMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date().toISOString(),\n      from,\n      to: to || 'all',\n      message,\n      type: type || 'user',\n      read: false,\n    };\n\n    // Append to chat file\n    await fs.appendFile(CHAT_FILE, JSON.stringify(chatMessage) + '\\n');\n\n    // Also publish to event bus for real-time notifications\n    try {\n      const today = new Date().toISOString().split('T')[0] as string;\n      const eventBusDir = path.join(process.cwd(), '_bus', 'events', today);\n      const eventBusFile = path.join(eventBusDir, 'events.jsonl');\n\n      // Ensure event bus directory exists\n      await fs.mkdir(eventBusDir, { recursive: true });\n\n      const event = {\n        event: 'team.chat.message',\n        version: 'v1',\n        id: chatMessage.id,\n        trace_id: 'tr_team_chat',\n        producer: from,\n        ts: chatMessage.timestamp,\n        signature: 'chat_message',\n        payload: {\n          from,\n          to: chatMessage.to,\n          message,\n          type,\n        },\n      };\n\n      await fs.appendFile(eventBusFile, JSON.stringify(event) + '\\n');\n    } catch (eventError) {\n      // Event bus is optional, don't fail if it errors\n      console.error('[TeamChat] Event bus error:', eventError);\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: chatMessage,\n    });\n  } catch (error) {\n    console.error('[TeamChat] Failed to send message:', error);\n    return NextResponse.json(\n      { error: 'Failed to send message' },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE - Clear chat history (admin only)\nexport async function DELETE() {\n  try {\n    await fs.writeFile(CHAT_FILE, '');\n\n    return NextResponse.json({\n      success: true,\n      message: 'Chat history cleared',\n    });\n  } catch (error) {\n    console.error('[TeamChat] Failed to clear history:', error);\n    return NextResponse.json(\n      { error: 'Failed to clear history' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}